/// <reference lib="webworker" />

import { setCacheNameDetails } from 'workbox-core';
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';

declare const self: ServiceWorkerGlobalScope;

setCacheNameDetails({
  prefix: 'slasher',
  suffix: 'v1',
  precache: 'precache',
  runtime: 'runtime',
});

// Precache all assets generated by next-pwa
precacheAndRoute(self.__WB_MANIFEST || []);

// Cache TMDB API responses
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/tmdb'),
  new StaleWhileRevalidate({
    cacheName: 'tmdb-api-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60, // 1 hour
      }),
    ],
  })
);

// Cache video source embeds
registerRoute(
  ({ url }) => {
    const videoHosts = [
      'vidlink.pro',
      'player.autoembed.cc',
      '2embed.cc',
      'multiembed.mov',
      '2embed.org',
      'autoembed.co',
      'vidsrc.xyz',
      'moviesapi.club',
      'nontongo.win',
      '111movies.com',
      'flicky.host',
      'vidjoy.pro',
      'embed.su',
      'primewire.tf',
      'smashystream.com',
      'vidstream.site'
    ];
    return videoHosts.some(host => url.hostname.includes(host));
  },
  new CacheFirst({
    cacheName: 'video-embeds-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  })
);

// Offline fallback
self.addEventListener('install', (event) => {
  const offlineFallbackPage = '/offline';
  event.waitUntil(
    caches.open('offline-cache').then((cache) => {
      return cache.add(offlineFallbackPage);
    })
  );
});

// Clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((cacheName) => cacheName.startsWith('slasher-'))
          .filter((cacheName) => cacheName !== 'slasher-precache-v1' && cacheName !== 'slasher-runtime-v1')
          .map((cacheName) => caches.delete(cacheName))
      );
    })
  );
});

